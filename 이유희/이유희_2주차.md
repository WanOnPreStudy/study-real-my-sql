## InnoDB 스토리지 엔진 아키텍처
- InnoDb 는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.
- 이 덕분에 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

## 프라이머리 키에 의한 클러스터링
- InnoDB : 클러스터링된 인덱스 사용
    - 장점 : 프라이머리 키를 이용한 레인지 스캔 빨리 처리될 수 있음.
    - ![a clustered index](https://i.stack.imgur.com/H3aOz.png)
- MyISAM : 클러스터링된 키 지원하지 않음.

## MVCC (Multi Version Concurrency Control)
- 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다.
- 목적 : 일관된 읽기
- 어떻게 동작?
  - InnoDB 는 언두 로그(Undo log)를 이용해 이 기능을 구현한다.
  - READ_COMMIT 인 서버에서 테이블 변경 처리 과정
    ![](images/updo-log-example.png)
    1. update 문장이 실행되면 커밋 실행 여부와 관계없이 버퍼 풀은 새로운 값으로 업데이트 된다.
    2. area 칼럼의 변경 전 값만 언두 로그 영역에 복사된다.
    3. 디스크의 데이터 파일에는 체크포인트나 innoDB Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있음.
    ```text
    mysql> SELECT * FROM member WHERE id=12;
    
    아직 commit 이나 rollback이 되지 않은 상태에서
    다른 사용자가 레코드를 조회하면 어디에 있는 데이터를 조회할 까?
    ```
    -> **```transaction_isolation``` 시스템 변수에 설정된 격리 수준에 따라 다르다.**
    - READ_UNCOMMITED : 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환한다. 
    - READ_COMMITED, REPEATABLE_READ, SERIALIAZBLE : 변경되기 이전의 내용을 보관하고 있는 언두 영역의 데이터 반환한다.
  - 정리 : 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달라지는 구조.
  - 단점 : 트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리돼야 하며, 자연히 언두 영역이 저장되는 시스템 테이블 스페이스의 공간이 많이 늘어나는 상황이 발생할 수도 있음.
  - 언두 영역의 내용은 언제 삭제 되는 가? 
    - 이 언두 영역을 필요로 하는 트랜잭션이 더는 없을 떄.