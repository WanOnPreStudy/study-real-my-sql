# 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소  
## 인덱스 키 값의 크기, B-Tree 깊이
* 일반적으로 DBMS 의 B-Tree는 자식 노드 개수가 가변적이고, 자식노드 수는 인덱스 페이지의 크기와 키 값의 크기에 따라 결정된다. 
	1. 키 값의 크기가 커지면 디스크로부터 읽어야하는 횟수가 늘어나고, 그만큼 느려진다. (16x1024/(16+12) -> 16x1024/(32+12))
	2. 캐시 크기는 고정되어있다. 메모리에 캐시해 둘 수 있는 레코드 수가 줄어들면 효율이 떨어진다. 

* B-Tree 깊이는 중요하지만 직접 제어할 수 없다. 
* B-Tree 깊이는 값을 검색할 때 몇번 랜덤하게 디스크를 읽어야하는지와 직결된다.
	1. 키 값의 크기가 커지고 인덱스페이지가 담을 수 있는 인덱스 키 값 개수가 적어지면, 깊이가 깊어져 디스크 읽기가 더 많이 필요하다.

-> **인덱스 키 값의 깊이는 가능하면 작게 만든다**.

## 선택도(기수성)
* 모든 인덱스 키 값 가운데 유니크한 값의 수
* 인덱스는 선택도가 높을수록 검색대상이 줄어들어 빨리 처리된다.

## 읽어야하는 레코드의 건수
* 읽어야하는 레코드의 건수를 기준으로 인덱스 사용여부에 따른 효율성을 판단할 수 있어야한다.
* 인덱스를 통해 읽을 레코드 개수가 전체 레코드의 20~25%를 넘어서면 인덱스를 사용해도 이점이 없다(MySQL 옵티마이저 내부 판단으로 동작)

# 8.3.4.4 인덱스 스킵 스캔 
MySQL 인덱스로 레코드를 읽는 방법. 
## 인덱스 레인지 스캔
* 검색해야 할 인덱스의 **범위**가 결정됐을 때 사용하는 방식
* 시작 위치를 찾으면(인덱스 탐색) 그때부터 리프노드 레코드를 순서대로 읽는다(인덱스 스캔)
* 검색 조건에 일치하는 리프노드는 데이터파일에서 레코드를 읽어오는 과정이 필요하다. 데이터에 따라 생략될 수 있다(커버링 인덱스)
## 인덱스 풀 스캔
* 인덱스를 사용하고 인덱스의 **처음부터 끝까지** 모두 읽는다.
* 인덱스를 사용한다는건 일반적으로 인덱스 레인지 스캔이나 루스 인댁스 스캔 방식으로 사용하는것을 의미한다. 풀 스캔은 오히려 _효율적으로 사용하지 못하는_ 예시이다.

## 루스 인덱스 스캔
* 듬성듬성하게 인덱스를 읽는다.
* 인덱스 레인지 스캔과 비슷하게 작동하나 중간에 필요없는 키 값은 스킵하고 다음으로 넘어간다. 
* 일반적으로 GROUP BY 또는 집합함수(MIN(), MAX())에 대해 최적화 할 때 사용된다
## 인덱스 스킵 스캔
* 기존 루스 인덱스 스캔은 GROUP BY 작업을 위해 도입되었다. 인덱스 스킵스캔은 WHERE 조건절의 검색을 위해 용도가 확장되었다.
* 새로 도입되어 필요한 조건이 존재한다
	1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야한다
	2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야한다