# 4.1 MySQL 엔진 아키텍처
## 1. MySQL의 전체 구조
![](4.1%20MySQL%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-12-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.49.09.png)
1. MySQL 엔진
	* 커넥션 핸들러(클라이언트로부터의 접속 및 쿼리 요청을 처리)
	* SQL 파서 및 전처리기
	* 옵티마이저(쿼리 최적화)
2. 스토리지 엔진
	* 데이터를 디스크 스토리지에 저장하거나 읽어옴
	* 여러개를 동시에 사용할 수 있다(MySQL 엔진은 하나만 가능)
	* 성능 향상을 위해 키 캐시나 InnoDB 버퍼 풀 내장
3. 핸들러 API
	*  MySQL 엔진의 쿼리 실행기에서 데이터 읽고 쓸 때 스토리지 엔진에 요청하는 API
	
## 2. MySQL 스레딩 구조
![](4.1%20MySQL%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-12-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.17.45.png)
MySQL 서버는 스레드 기반으로 동작한다. 

1. 포그라운드 스레드(클라이언트 스레드)
	* 서버에 접속된 클라이언트의 수만큼 존재, 
	* 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
	* 커넥션을 종료하면 해당 커넥션의 스레드는 스레드 캐시로 되돌아감
	* 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 데이터가 없다면 직접 디스크의 데이터나 인덱스 파일로부터 읽어옴
2. 백그라운드 스레드
	* InnoDB에서는 여러 작업을 백그라운드에서 수행
		* 인서트 버퍼(Insert Buffer)를 병합하는 스레드	
		* **로그**를 디스크로 기록하는 스레드	
		* InnoDB 버퍼 풀의 데이터를 디스크에 **기록**하는 스레드	
		-> 쿼리로 데이터가 변경될 때 데이터가 디스크에 완전히 저장될 때 까지 기다리지 않아도 된다
		* 데이터를 버퍼로 읽어 오는 스레드	
		* 잠금이나 데드락을 모니터링하는 스레드


## 3. 메모리 할당 및 사용 구조
1. 글로벌 메모리 영역
	* MySQL 서버 시작하면서 운영체제로부터 할당
	* 클라이언트 스레드 수와 무관
	* 여러개가 생성이 되어도 모든 스레드에 의해 공유된다
	* 테이블 캐시, InnoDB 버퍼 풀, InnoDB 어댑티브 해시 인덱스, InnoDB 리드 로그 버퍼 …

2. 로컬 메모리 영역
	* 클라이언트 스레드가 쿼리 처리하는데 사용하는 영역
	* 클라이언트 스레드별로 독립적으로 할당되며 공유되지않는다
	* 일반적으로 크기 신경쓰지 않지만 최악의 경우 대비해서 적절히 설정해서 사용
	* 정렬 버퍼, 조인 버퍼, 바이너리 로그 캐시, 네트워크 버퍼…

## 4. 플러그인 스토리지 엔진 모델
![](4.1%20MySQL%20%E1%84%8B%E1%85%A6%E1%86%AB%E1%84%8C%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-12-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.31.09.png)
* 검색 파서, 인증 등 부가적인 기능이 플러그인으로 구현되어 제공

* 거의 **데이터 읽고 쓰는 작업만** 스토리지 엔진에 의해 처리된다
* 하나의 쿼리작업은 여러 하위 작업으로 나뉘는데, **각 하위 작업이 MySQL 엔진 영역에서 처리되는지, 스토리지 엔진 영역에서 처리되는지 구분할 수 있어야함**
* MySQL서버에 포함되지 않은 스토리지 엔진 사용하려면 MySQL서버를 다시 컴파일 해야하는데 플러그인 형태로 빌드된 스토리지 라이브러리 끼워넣는 방식으로 사용할 수도 있음

* 단점
	 * MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
	 * MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)	
	 * 상호 의존 관계를 설정할 수 없어서 초기화가 어려움
	-> 컴포넌트 

## 5. 컴포넌트
플러그인 구조의 단점을 보완

## 6. 쿼리 실행 구조
* 쿼리 파서
	* 문장을 토큰으로 분리해 트리형태로 만든다
	* 기본 문법 오류 발견
* 전처리기
	* 각 토큰을 테이블, 칼럼 이름에 매핑해 객체의 존재 여부와 접근 권한을 확인
* 옵티마이저(최적화) -> 책에서 옵티마이저 효과적으로 사용하는 법 주로 다룸
* 실행 엔진
	* 핸들러의 결과를 다른 핸들러의 입력으로 연결
* 핸들러(스토리지 엔진)
	* 서버 가장 밑단에서 요청에따라 데이터를 읽고 저장

## 7. 복제 
-> 16장에서 다룸

## 8. 쿼리 캐시
* Sql 실행 결과를 메모리에 캐시해서 빠른 성능 유도
* 하지만 데이터 변경되면 관련 캐시 전부 삭제해서 성능 저하, 버그가 있었음
-> 8.0으로 올라오면서 제거됨
## 9. 스레드 풀
(엔터프라이즈 에디션에서만 지원
-> Percona Server의 스레드 풀 기능 설명)
* MySQL 서버의 CPU가 제한된 개수 스레드 처리에만 집중하게 한다(자원 소모를 줄임)
* 실 서비스에서 눈에 띄게 성능 향상되지않고 더 느려질수도있음
* 기본적으로 CPU 코어 개수만큼 스레드 그룹 생성
* 선순위 큐, 후순위 큐로 특정 쿼리 우선적으로 처리할 수도 있음

## 10. 트랜잭션 지원 메타데이터
데이터베이스 서버의 테이블 구조와 스토어드 프로그램 정보
파일기반 메타데이터는 트랜잭션을 지원하지않아 일관성이 깨지는 문제
-> 8.0 에서는 관련 정보(시스템 테이블)를 모두 InnoDB테이블에 저장