# 8.3 B-Tree 인덱스

1. B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용된다.
2. B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

## 8.3.1 구조 및 특성

1. 최상위에 하나의 `루트노드`와 중간의 `브랜치노드`, 최하위에 `리프노드`가 존재한다.
2. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
3. 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
4. InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한번 검색해야 한다.

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 인덱스 키 추가

1. B-Tree에 새로운 키가 저장될 때 B-Tree상의 적절한 위치를 검색한다.
2. 저장될 위치가 결정되면 레코드의 값과 대상 레코드의 주소정보를 B-Tree의 리프 노드에 저장한다.
3. 리프노드가 꽉 차서 더는 저장 할 수 없을 때는 리프노드가 상위 브랜치 노드까지 분리된다.(많은 비용이 듬)

### 8.3.2.2 인덱스 키 삭제

1. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.
2. 이렇게 삭제 마킹된 인덱스 키 공간은 그대로 방치하거나 재활용할 수 있다.

### 8.3.2.3 인덱스 키 변경

1. 인덱스 키 값이 변경될 때, 단순히 인덱스 값만 변경하는 것은 불가능하다.
2. 기존의 키값을 삭제하고, 다시 새로운 키 값을 추가하는 형태로 처리된다.

### 8.3.2.4 인덱스 키 검색

1. Insert, Update, Delete 작업을 할 때 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다.
2. B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.
3. 인덱스의 키값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree이 빠른 검색 기능을 사용핳 수 없다.
4. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.따라서, UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히
   사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.1 인덱스 키 값의 크기

1. InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 한다.
2. 일반적으로 DBMS의 B-Tree의 자식 노드의 개수가 가변적인 구조이다. 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 갯수가 정해진다.
3. 인덱스 키 갯수 = 스토리지 엔진의 페이지 크기/(인덱스 키값의 크기 + 자식노드주소 크기)
4. 인덱스 키 값이 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.
5. 버퍼 풀에서도 캐시 영역의 크기가 제한적이기 때문에 인덱스 크기가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다.

### 8.3.3.2 B-Tree 깊이

1. B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.
2. 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이
   필요하게 된다는 것을 의미한다.

### 8.3.3.3 선택도(기수성)

1. 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
2. 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
3. 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

### 8.3.3.4 읽어야 하는 레코드의 건수

1. 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
2. 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색이라고 한다.
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔이라고 한다.(1번과 2번을 합쳐서 인덱스 스캔으로 통칭하기도 한다.)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.

### 8.3.4.2 인덱스 풀 스캔

1. 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.

### 8.3.4.3 루스 인덱스 스캔

1. 타이트 인덱스 스캔("인덱스 레인지 스캔" 과 "인덱스 풀 스캔")의 상반된 개념이다.
2. 인덱스를 스캔 할때 중간에 필요치 않은 인덱스 키를 무시하고 다음으로 넘어가는 형태로 처리한다.

### 8.3.4.4 인덱스 스킵 스캔

1. MySQL 8.0버전부터 다중 인덱스에서 한 칼럼이 누락되도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.
2. 인덱스 스킵 스캔의 단점
    1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
    2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)

## 8.3.5 다중 칼럼 인덱스

1. 다중 칼럼 인덱스인 경우에는 그 전 칼럼 인덱스에 의존적이다.
    1. 예를 들어 dept_no 칼럼과 emp_no 칼럼으로 인덱스가 생성되어 있다면, 먼저 dept_no 칼럼순으로 정렬된 다음 그 안에서 emp_no칼럼순으로 정렬된다.

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스가 오름차순으로 생성되었다고 오름차순으로만 읽을 수 있는것이 아니라, 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정된다.

### 8.3.6.1 인덱스의 정렬

1. MySQL5.7 버전까지는 칼럼단위로 정렬 순서를 혼합해서 인덱스를 생성 할 수 없었지만 MySQL8.0버전부터는 다음과 같은 형태의 정렬 순서를 혼합한 인덱스를 생성할 수 있다.

```mysql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

#### 8.3.6.1.1 인덱스 스캔 방향

1. 인덱스 생성 시점에 오름차순 내림차순 정렬이 결정되지만 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.

#### 8.3.6.1.2 내림차순 인덱스

<img width="600" alt="READ_UNCOMMITTED.png" src="https://user-images.githubusercontent.com/18053020/216818692-7ff612cc-65f6-4ea1-8be5-2262eeabe2e0.png">

1. 인덱스 용어
    1. 오름차순 인덱스
        - 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
    2. 내림차순 인덱스
        - 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬된 인덱스
    3. 인덱스 정순 스캔
        - 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 왼쪽 페이지부터 오른쪽으로 스캔
    4. 인덱스 역순 스캔
        - 인덱스 키의 크고 작음에 관계없이 인덱스 리프 노드의 오른쪽 페이지부터 왼쪽으로 스캔
2. 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느린 이유
    1. 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
    2. 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

### 8.3.7.1 비교 조건의 종류와 효율성

```mysql
SELECT *
FROM dept_emp
WHERE dept_no = 'd002'
  AND emp_no >= 10114;
```

1. INDEX(dept_no, emp_no) - 작업 범위 결정 조건
    - 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능
2. INDEX(emp_no, dept_no) - 필터링 조건
    - 조건이 많다고 쿼리의 처리 성능이 좋아지지 않음

### 8.3.7.2 인덱스의 가용성

1. 하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색이 불가능하다.
2. 예제 1

- 조건절에 주어진 상수값('%mer')에는 왼쪽 부분이 고정되지 않아서 인덱스 레인지 스캔 방식의 검색이 불가능하다.

```mysql
SELECT *
from employees
WHERE first_name LIKE '%mer';
```

3. 예제 2

- 인덱스가 (dept_no,emp_no) 칼럼 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no 조건없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다.

```mysql
SELECT *
from dept_emp
WHERE emp_no >= 10144;
```

### 8.3.7.3 가용성과 효율성 판단

기본적으로 B-Tree 인덱스의 특성상 다음 조건에서는 사용할 수 없다.

1. NOT-EQUAL로 비교된 경우("<>","NOT IN","NOT BETWEEN","IS NOT NULL")
    - WHERE column <> 'N'
    - WHERE column NOT IN (10,11,12)
    - WHERE column IS NOT NULL
2. LIKE '%??'(앞부분이 아닌 뒷부분 일치)형태로 문자열 패턴이 비교된 경우
    - WHRER column LIKE '%승환'
    - WHRER column LIKE '_승환'
    - WHRER column LIKE '%승%'
3. 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
    - WHERE SUBSTRING(column,1,1) = 'X'
    - WHERE DAYOFMONTH(column) = 1
4. NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
    - WHERE column = deterministic_function()
5. 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
    - WHERE char_column = 10
6. 문자열 데이터 타입의 콜레이션이 다른 경우
    - WHERE utf8_bin_char_column = euckr_bin_char_column
7. 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
    - column_1 칼럼에 대한 조건이 없는 경우
    - column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우
8. 작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작은 임의의 값을 의미)
    - column_1 ~ column_(i-1)칼럼까지 동등 비교 형태("=" 또는 "IN")로 비교
    - column_i 칼럼에 대해 다음 연산자 중 하나로 비교
        - 동등비교("=" 또는 "IN")
        - 크다 작다 형태(">" 또는 "<")
        - LIKE로 좌측 일치 패턴(LIKE '승환%')