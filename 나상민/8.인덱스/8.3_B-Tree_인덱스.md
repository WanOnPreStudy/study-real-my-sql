# 8.3 B-Tree 인덱스

1. B-Tree는 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용된다.
2. B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

## 8.3.1 구조 및 특성

1. 최상위에 하나의 `루트노드`와 중간의 `브랜치노드`, 최하위에 `리프노드`가 존재한다.
2. 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.
3. 인덱스의 키 값은 모두 정렬돼 있지만, 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서로 저장돼 있다.
4. InnoDB 스토리지 엔진에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree 를 다시 한번 검색해야 한다.

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 인덱스 키 추가

1. B-Tree에 새로운 키가 저장될 때 B-Tree상의 적절한 위치를 검색한다.
2. 저장될 위치가 결정되면 레코드의 값과 대상 레코드의 주소정보를 B-Tree의 리프 노드에 저장한다.
3. 리프노드가 꽉 차서 더는 저장 할 수 없을 때는 리프노드가 상위 브랜치 노드까지 분리된다.(많은 비용이 듬)

### 8.3.2.2 인덱스 키 삭제

1. 해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다.
2. 이렇게 삭제 마킹된 인덱스 키 공간은 그대로 방치하거나 재활용할 수 있다.

### 8.3.2.3 인덱스 키 변경

1. 인덱스 키 값이 변경될 때, 단순히 인덱스 값만 변경하는 것은 불가능하다.
2. 기존의 키값을 삭제하고, 다시 새로운 키 값을 추가하는 형태로 처리된다.

### 8.3.2.4 인덱스 키 검색

1. Insert, Update, Delete 작업을 할 때 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다.
2. B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다.
3. 인덱스의 키값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree이 빠른 검색 기능을 사용핳 수 없다.
4. InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현돼 있다.따라서, UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히
   사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다.

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.1 인덱스 키 값의 크기

1. InnoDB 스토리지 엔진에서 디스크에 데이터를 저장하는 가장 기본 단위를 페이지라고 한다.
2. 일반적으로 DBMS의 B-Tree의 자식 노드의 개수가 가변적인 구조이다. 인덱스의 페이지 크기와 키 값의 크기에 따라 자식 노드의 갯수가 정해진다.
3. 인덱스 키 갯수 = 스토리지 엔진의 페이지 크기/(인덱스 키값의 크기 + 자식노드주소 크기)
4. 인덱스 키 값이 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고, 그만큼 느려진다는 것을 의미한다.
5. 버퍼 풀에서도 캐시 영역의 크기가 제한적이기 때문에 인덱스 크기가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다.

### 8.3.3.2 B-Tree 깊이

1. B-Tree의 깊이는 MySQL에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.
2. 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이
   필요하게 된다는 것을 의미한다.

### 8.3.3.3 선택도(기수성)

1. 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
2. 인덱스 키 값 가운데 중복된 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
3. 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

### 8.3.3.4 읽어야 하는 레코드의 건수

1. 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
2. 인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다.

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색이라고 한다.
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔이라고 한다.(1번과 2번을 합쳐서 인덱스 스캔으로 통칭하기도 한다.)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.

### 8.3.4.2 인덱스 풀 스캔

1. 인덱스를 사용하지만 인덱스 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.

### 8.3.4.3 루스 인덱스 스캔

1. 타이트 인덱스 스캔("인덱스 레인지 스캔" 과 "인덱스 풀 스캔")의 상반된 개념이다.
2. 인덱스를 스캔 할때 중간에 필요치 않은 인덱스 키를 무시하고 다음으로 넘어가는 형태로 처리한다.

### 8.3.4.4 인덱스 스킵 스캔

1. MySQL 8.0버전부터 다중 인덱스에서 한 칼럼이 누락되도 인덱스 검색이 가능하게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.
2. 인덱스 스킵 스캔의 단점
    1. WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
    2. 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)
